#포인터의 개념
지금까지의 변수는 그 자체로 자신의 자료형에 맞는 값을 저장
포인터(pointer) 변수는 특이한 변수로, 메모리 주소를 저장함. **
ex) int형 변수가 저장된 메모리 주소의 위치값을 int*, 인트형 포인터로 저장함

즉, 컴퓨터 메모리에 바로 접근할 수 있게 해줌
ex) int a = 5;
int *b = &a;
5라는 값이 저장된 메모리 주소인 OxAFBdfdf
 ** b의 정보가 저장된 메모리 주소도 따로 존재

#선언
자료형 뒤에 *변수명 을 통해 선언.
*b 는 5라는 값 자체를 반환함
>> 포인터 변수 b가 가리키는 주소의 '값'을 할당받음

* 별은 '간접참조 연산자'라고 부름
>> 현재 포인터가 가리키고 있는 주소에 들어있는 '값'을 참조

#포인터 관련 연산자

- 주소연산자 & - 변수 앞에 붙어서 변수의 메모리 시작 주소 값을 구함
ex) scanf( & a ) >> a라는 값이 저장된 메모리의 주소 값
   + 포인터 변수의 값으로 들어갈 수 있음

- 포인터 * - 포인터 변수를 선언할 때 사용

- 간접참조연산자 * 선언된 포인터 변수가 가리키는 변수를 구함

*** 선언할 때 *b와 사용할 때 *b는 다름 ***


#include <stdio.h>

int main(void) {
	int a = 5;
	int *b = &a;
	printf("%d\n", *b);
	system("pause");
	return 0;
}	

실제로 int는 4bytes이므로 연속된 메모리 4칸 차지.

#배열의 각 원소의 주소 값 출력하기

#include <stdio.h>
int main(void) {
	int a[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
	int i;
	for (i = 0; i < 10; i++) {
		printf("%d\n", &a[i]);
	}
	system("pause");
	return 0;
}

#포인터의 강력한 기능
포인터는 컴퓨터 시스템의 특정한 메모리에 바로 접근할 수 있음
따라서 기존에 존재하던 중요한 메모리 영역에 접근하지 않도록 해야함

#포인터의 포인터 또한 존재 가능

#include <stdio.h>

int main(void) {
	int a = 5;
	int* b = &a;
	int** c = &b;
	printf("%d", **c);
	return 0;
}

** 포인터의 포인터로 c를 선언할 때, 할당 값으로 &*b를 넣으면 오류 발생. **



#배열과 포인터는 사실 동일함.
배열을 선언한 이후에는 그 이름 자체가 포인터 변수와 동일함 ** 주소변수

#include <stdio.h>

int main(void) {
	int a[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
	int* b = a;
	printf("%d", b[2]);
	system("pause");
	return 0;
}

** *b 할당 시, *a라고 입력하면 에러 남
** printf 에 *b[2] 라고 입력시, *의 피연산자는 포인터여야 한다고 나옴.
